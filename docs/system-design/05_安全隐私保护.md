# 05_安全隐私保护方案

## 安全架构概述

### 安全目标
1. **数据安全**: 保护儿童和家庭敏感信息不被泄露
2. **访问控制**: 确保只有授权用户才能访问相应数据
3. **传输安全**: 保证数据在传输过程中的安全性
4. **存储安全**: 保证数据在存储过程中的安全性
5. **操作安全**: 防止恶意操作和系统滥用

### 安全架构图
```
┌─────────────────────────────────────────────────────────────┐
│                    应用安全层 (Application Security)        │
├─────────────────────────────────────────────────────────────┤
│  输入验证  │  输出编码  │  权限控制  │  会话管理          │
├─────────────────────────────────────────────────────────────┤
│                    网络安全层 (Network Security)            │
├─────────────────────────────────────────────────────────────┤
│  HTTPS传输  │  API安全  │  防火墙  │  DDoS防护           │
├─────────────────────────────────────────────────────────────┤
│                    数据安全层 (Data Security)                │
├─────────────────────────────────────────────────────────────┤
│  数据加密  │  访问控制  │  数据脱敏  │  备份恢复          │
├─────────────────────────────────────────────────────────────┤
│                    基础安全层 (Infrastructure Security)      │
├─────────────────────────────────────────────────────────────┤
│  身份认证  │  授权管理  │  审计日志  │  安全监控          │
└─────────────────────────────────────────────────────────────┘
```

## 身份认证与授权

### 多因素认证 (MFA)
```javascript
// 多因素认证流程
const multiFactorAuth = {
  // 第一因素：微信登录
  async wechatLogin(code) {
    const result = await wx.cloud.callFunction({
      name: 'auth',
      data: {
        action: 'wechatLogin',
        code: code
      }
    })

    return result.data
  },

  // 第二因素：短信验证码
  async sendSmsCode(phone) {
    const code = Math.floor(100000 + Math.random() * 900000)

    await wx.cloud.callFunction({
      name: 'auth',
      data: {
        action: 'sendSms',
        phone: phone,
        code: code
      }
    })

    // 将验证码存储到缓存，5分钟过期
    await cache.set(`sms:${phone}`, code, 300)
  },

  // 验证短信验证码
  async verifySmsCode(phone, code) {
    const cachedCode = await cache.get(`sms:${phone}`)

    if (!cachedCode || cachedCode !== code) {
      throw new Error('验证码错误或已过期')
    }

    await cache.delete(`sms:${phone}`)
    return true
  }
}
```

### 角色权限控制
```javascript
// 权限验证中间件
const permissionMiddleware = {
  // 检查用户是否有特定权限
  async checkPermission(userId, permission) {
    const user = await getUserById(userId)
    const userPermissions = user.role.permissions || []

    return userPermissions.includes(permission)
  },

  // 检查数据访问权限
  async checkDataAccess(userId, resourceId, resourceType) {
    const user = await getUserById(userId)

    switch (resourceType) {
      case 'family':
        return await checkFamilyAccess(user, resourceId)
      case 'activity':
        return await checkActivityAccess(user, resourceId)
      default:
        return false
    }
  },

  // 检查家庭数据访问权限
  async checkFamilyAccess(user, familyId) {
    // 管理员可以访问所有家庭
    if (user.role.roleCode === 'HQ_ADMIN') {
      return true
    }

    // 小家站长可以访问本小家的家庭
    if (user.role.roleCode === 'STATION_MANAGER') {
      const family = await getFamilyById(familyId)
      return family.stationId === user.role.stationId
    }

    // 社工可以访问负责的家庭
    if (user.role.roleCode === 'FULLTIME_SOCIAL_WORKER') {
      const family = await getFamilyById(familyId)
      return family.services.socialWorkerId === user._id
    }

    // 家长只能访问自己的家庭
    if (user.role.roleCode === 'RESIDENT_PARENT') {
      const family = await getFamilyByUserId(user._id)
      return family._id === familyId
    }

    return false
  }
}
```

### 会话管理
```javascript
// 会话管理服务
class SessionManager {
  constructor() {
    this.sessions = new Map()
    this.sessionTimeout = 24 * 60 * 60 * 1000 // 24小时
  }

  // 创建会话
  createSession(userId, deviceInfo) {
    const sessionId = this.generateSessionId()
    const session = {
      sessionId,
      userId,
      deviceInfo,
      createTime: Date.now(),
      lastAccessTime: Date.now(),
      isActive: true
    }

    this.sessions.set(sessionId, session)
    return sessionId
  }

  // 验证会话
  validateSession(sessionId) {
    const session = this.sessions.get(sessionId)

    if (!session || !session.isActive) {
      return null
    }

    // 检查会话是否过期
    if (Date.now() - session.lastAccessTime > this.sessionTimeout) {
      this.invalidateSession(sessionId)
      return null
    }

    // 更新最后访问时间
    session.lastAccessTime = Date.now()
    return session
  }

  // 销毁会话
  invalidateSession(sessionId) {
    this.sessions.delete(sessionId)
  }

  // 生成会话ID
  generateSessionId() {
    return require('crypto').randomBytes(32).toString('hex')
  }
}
```

## 数据保护

### 数据加密
```javascript
// 数据加密服务
class DataEncryption {
  constructor() {
    this.algorithm = 'aes-256-gcm'
    this.keyLength = 32
    this.ivLength = 16
    this.tagLength = 16
  }

  // 生成加密密钥
  generateKey() {
    return require('crypto').randomBytes(this.keyLength)
  }

  // 加密数据
  encrypt(plaintext, key) {
    const iv = require('crypto').randomBytes(this.ivLength)
    const cipher = require('crypto').createCipher(this.algorithm, key, iv)

    let encrypted = cipher.update(plaintext, 'utf8', 'hex')
    encrypted += cipher.final('hex')

    const tag = cipher.getAuthTag()

    return {
      encrypted,
      iv: iv.toString('hex'),
      tag: tag.toString('hex')
    }
  }

  // 解密数据
  decrypt(encryptedData, key) {
    const { encrypted, iv, tag } = encryptedData
    const decipher = require('crypto').createDecipher(
      this.algorithm,
      key,
      Buffer.from(iv, 'hex')
    )

    decipher.setAuthTag(Buffer.from(tag, 'hex'))

    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')

    return decrypted
  }
}

// 敏感字段加密
const sensitiveFields = {
  idCard: true,
  phone: true,
  address: true,
  bankAccount: true,
  medicalRecord: true
}

// 数据加密中间件
const encryptMiddleware = {
  // 保存前加密
  async beforeSave(data) {
    const encryptedData = { ...data }

    for (const field in data) {
      if (sensitiveFields[field] && data[field]) {
        const encrypted = await this.encryptField(data[field])
        encryptedData[field] = encrypted
      }
    }

    return encryptedData
  },

  // 读取后解密
  async afterRead(data) {
    const decryptedData = { ...data }

    for (const field in data) {
      if (sensitiveFields[field] && data[field]) {
        const decrypted = await this.decryptField(data[field])
        decryptedData[field] = decrypted
      }
    }

    return decryptedData
  }
}
```

### 数据脱敏
```javascript
// 数据脱敏服务
class DataMasking {
  constructor() {
    this.maskingRules = {
      // 身份证号脱敏
      idCard: (value) => {
        return value.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2')
      },

      // 手机号脱敏
      phone: (value) => {
        return value.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
      },

      // 地址脱敏
      address: (value) => {
        return value.replace(/(.{6}).*/, '$1***')
      },

      // 银行卡号脱敏
      bankCard: (value) => {
        return value.replace(/(\d{4})\d+(\d{4})/, '$1 **** **** $2')
      }
    }
  }

  // 根据用户角色脱敏数据
  maskData(data, userRole) {
    const maskedData = { ...data }

    // 根据角色确定脱敏规则
    const maskingLevel = this.getMaskingLevel(userRole)

    for (const field in data) {
      if (this.maskingRules[field]) {
        maskedData[field] = this.applyMasking(data[field], field, maskingLevel)
      }
    }

    return maskedData
  }

  // 获取脱敏级别
  getMaskingLevel(userRole) {
    const levelMap = {
      'HQ_ADMIN': 0,        // 不脱敏
      'STATION_MANAGER': 1,  // 轻度脱敏
      'FULLTIME_SOCIAL_WORKER': 2, // 中度脱敏
      'VOLUNTEER': 3,        // 重度脱敏
      'RESIDENT_PARENT': 4,  // 仅显示自己信息
      'VISITOR': 5           // 完全隐藏
    }

    return levelMap[userRole] || 5
  }

  // 应用脱敏规则
  applyMasking(value, field, level) {
    if (level === 0) return value // 不脱敏
    if (level === 5) return '***' // 完全隐藏

    return this.maskingRules[field](value)
  }
}
```

### 数据访问控制
```javascript
// 数据访问控制服务
class DataAccessControl {
  // 检查数据访问权限
  async checkDataAccess(userId, operation, data) {
    const user = await getUserById(userId)

    // 基础权限检查
    if (!this.hasBasicPermission(user, operation)) {
      throw new Error('没有操作权限')
    }

    // 数据级别权限检查
    if (!this.hasDataLevelPermission(user, data)) {
      throw new Error('没有数据访问权限')
    }

    // 字段级别权限检查
    const filteredData = this.filterFields(user, data)

    return filteredData
  }

  // 基础权限检查
  hasBasicPermission(user, operation) {
    const permissions = user.role.permissions || []
    return permissions.includes(operation)
  }

  // 数据级别权限检查
  hasDataLevelPermission(user, data) {
    // 检查用户是否可以访问该数据
    switch (data.type) {
      case 'family':
        return this.canAccessFamily(user, data)
      case 'activity':
        return this.canAccessActivity(user, data)
      default:
        return false
    }
  }

  // 字段过滤
  filterFields(user, data) {
    const allowedFields = this.getAllowedFields(user.role.roleCode)
    const filteredData = {}

    for (const field of allowedFields) {
      if (data[field] !== undefined) {
        filteredData[field] = data[field]
      }
    }

    return filteredData
  }

  // 获取允许访问的字段
  getAllowedFields(roleCode) {
    const fieldMap = {
      'HQ_ADMIN': ['*'], // 所有字段
      'STATION_MANAGER': ['id', 'name', 'phone', 'address', 'status'],
      'FULLTIME_SOCIAL_WORKER': ['id', 'name', 'medicalInfo', 'careRecords'],
      'VOLUNTEER': ['id', 'name', 'basicInfo'],
      'RESIDENT_PARENT': ['id', 'name', 'ownInfo'],
      'VISITOR': ['id', 'name']
    }

    return fieldMap[roleCode] || []
  }
}
```

## 网络安全

### HTTPS配置
```javascript
// HTTPS配置
const httpsConfig = {
  // 强制HTTPS
  enforceHttps: true,

  // SSL/TLS配置
  sslConfig: {
    protocol: 'TLSv1.2',
    ciphers: [
      'ECDHE-RSA-AES128-GCM-SHA256',
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-SHA256',
      'ECDHE-RSA-AES256-SHA384'
    ],
    honorCipherOrder: true
  },

  // HSTS配置
  hstsConfig: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}
```

### API安全
```javascript
// API安全中间件
const apiSecurity = {
  // 请求频率限制
  rateLimiter: rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 100, // 最大请求数
    message: '请求过于频繁，请稍后再试'
  }),

  // 请求大小限制
  requestSizeLimit: limit({
    limit: '10mb',
    message: '请求体过大'
  }),

  // 参数验证
  validateParams(req, res, next) {
    const schema = this.getValidationSchema(req.path)

    if (!schema) {
      return next()
    }

    const { error } = schema.validate(req.body)

    if (error) {
      return res.status(400).json({
        success: false,
        message: '参数验证失败',
        errors: error.details
      })
    }

    next()
  },

  // XSS防护
  xssProtection: (req, res, next) => {
    res.setHeader('X-XSS-Protection', '1; mode=block')
    res.setHeader('X-Content-Type-Options', 'nosniff')
    next()
  }
}
```

### CORS配置
```javascript
// CORS配置
const corsConfig = {
  origin: [
    'https://your-domain.com',
    'https://admin.your-domain.com'
  ],
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}
```

## 应用安全

### 输入验证
```javascript
// 输入验证服务
class InputValidation {
  constructor() {
    this.schemas = {
      // 用户注册验证
      userRegistration: {
        phone: {
          type: 'string',
          pattern: /^1[3-9]\d{9}$/,
          required: true
        },
        password: {
          type: 'string',
          minLength: 8,
          pattern: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/,
          required: true
        },
        email: {
          type: 'string',
          format: 'email',
          required: false
        }
      },

      // 家庭信息验证
      familyInfo: {
        childName: {
          type: 'string',
          minLength: 1,
          maxLength: 50,
          required: true
        },
        childGender: {
          type: 'number',
          enum: [1, 2],
          required: true
        },
        diagnosis: {
          type: 'string',
          maxLength: 500,
          required: true
        }
      }
    }
  }

  // 验证输入
  validate(input, schemaName) {
    const schema = this.schemas[schemaName]

    if (!schema) {
      throw new Error(`验证模式 ${schemaName} 不存在`)
    }

    const result = this.validateSchema(input, schema)

    if (!result.valid) {
      throw new Error('输入验证失败: ' + result.errors.join(', '))
    }

    return result.data
  }

  // 清理输入
  sanitize(input) {
    if (typeof input !== 'string') {
      return input
    }

    return input
      .trim()
      .replace(/[<>]/g, '') // 移除HTML标签
      .replace(/javascript:/gi, '') // 移除javascript协议
      .replace(/on\w+=/gi, '') // 移除事件处理器
  }
}
```

### 输出编码
```javascript
// 输出编码服务
class OutputEncoding {
  // HTML编码
  htmlEncode(str) {
    if (typeof str !== 'string') {
      return str
    }

    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
  }

  // URL编码
  urlEncode(str) {
    if (typeof str !== 'string') {
      return str
    }

    return encodeURIComponent(str)
  }

  // JSON编码
  jsonEncode(data) {
    return JSON.stringify(data)
  }

  // 防止XSS攻击
  preventXSS(data) {
    if (typeof data === 'string') {
      return this.htmlEncode(data)
    }

    if (typeof data === 'object' && data !== null) {
      const encoded = {}
      for (const key in data) {
        encoded[key] = this.preventXSS(data[key])
      }
      return encoded
    }

    return data
  }
}
```

### SQL注入防护
```javascript
// SQL注入防护
class SqlInjectionProtection {
  // 参数化查询
  async query(sql, params) {
    // 使用参数化查询防止SQL注入
    const result = await db.query(sql, params)
    return result
  }

  // 输入过滤
  filterInput(input) {
    if (typeof input !== 'string') {
      return input
    }

    // 移除潜在的SQL注入字符
    return input
      .replace(/['"\\;]/g, '')
      .replace(/--/g, '')
      .replace(/\/\*/g, '')
      .replace(/\*\//g, '')
  }

  // 白名单验证
  validateField(fieldName, value) {
    const whiteList = {
      'id': /^\d+$/,
      'name': /^[a-zA-Z\u4e00-\u9fa5\s]+$/,
      'phone': /^1[3-9]\d{9}$/,
      'email': /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    }

    const pattern = whiteList[fieldName]

    if (pattern && !pattern.test(value)) {
      throw new Error(`字段 ${fieldName} 包含非法字符`)
    }

    return value
  }
}
```

## 隐私保护

### 隐私政策
```javascript
// 隐私政策管理
class PrivacyPolicy {
  constructor() {
    this.policyVersion = '1.0.0'
    this.lastUpdated = '2025-10-15'
  }

  // 获取隐私政策
  getPolicy() {
    return {
      version: this.policyVersion,
      lastUpdated: this.lastUpdated,
      content: {
        dataCollection: this.getDataCollectionPolicy(),
        dataUsage: this.getDataUsagePolicy(),
        dataSharing: this.getDataSharingPolicy(),
        userRights: this.getUserRights(),
        contactInfo: this.getContactInfo()
      }
    }
  }

  // 数据收集政策
  getDataCollectionPolicy() {
    return {
      personalInfo: [
        '姓名、联系方式、身份证号',
        '用于身份验证和联系'
      ],
      medicalInfo: [
        '诊断信息、治疗方案',
        '用于提供适当的关怀服务'
      ],
      usageInfo: [
        '应用使用记录、设备信息',
        '用于改善服务体验'
      ]
    }
  }

  // 数据使用政策
  getDataUsagePolicy() {
    return {
      primaryUse: '提供小家服务',
      secondaryUse: '改善服务质量',
      analytics: '服务统计分析',
      communication: '与服务相关的沟通'
    }
  }

  // 用户权利
  getUserRights() {
    return {
      access: '访问个人数据',
      correction: '更正不准确信息',
      deletion: '删除个人数据',
      portability: '数据可携带性',
      objection: '反对数据处理'
    }
  }
}
```

### 用户同意管理
```javascript
// 用户同意管理
class ConsentManager {
  constructor() {
    this.consents = new Map()
  }

  // 记录用户同意
  recordConsent(userId, consentType, consentData) {
    const consent = {
      userId,
      consentType,
      consentData,
      timestamp: new Date(),
      ipAddress: consentData.ipAddress,
      userAgent: consentData.userAgent
    }

    this.consents.set(`${userId}:${consentType}`, consent)

    // 持久化到数据库
    this.saveConsentToDatabase(consent)
  }

  // 检查用户同意
  hasConsent(userId, consentType) {
    const consent = this.consents.get(`${userId}:${consentType}`)

    if (!consent) {
      return false
    }

    // 检查同意是否过期
    if (this.isConsentExpired(consent)) {
      return false
    }

    return consent.consentData.agreed
  }

  // 撤销同意
  revokeConsent(userId, consentType) {
    const consentKey = `${userId}:${consentType}`
    const consent = this.consents.get(consentKey)

    if (consent) {
      consent.consentData.agreed = false
      consent.timestamp = new Date()

      // 更新数据库
      this.updateConsentInDatabase(consent)
    }
  }

  // 同意是否过期
  isConsentExpired(consent) {
    const maxAge = 365 * 24 * 60 * 60 * 1000 // 1年
    return Date.now() - consent.timestamp.getTime() > maxAge
  }
}
```

### 数据最小化原则
```javascript
// 数据最小化原则实现
class DataMinimization {
  constructor() {
    this.requiredFields = {
      userRegistration: ['phone', 'password'],
      familyApplication: ['childName', 'diagnosis', 'hospital'],
      activityRegistration: ['activityId', 'participantName']
    }
  }

  // 获取最小必需字段
  getRequiredFields(operation) {
    return this.requiredFields[operation] || []
  }

  // 过滤非必需字段
  filterRequiredFields(data, operation) {
    const requiredFields = this.getRequiredFields(operation)
    const filteredData = {}

    for (const field of requiredFields) {
      if (data[field] !== undefined) {
        filteredData[field] = data[field]
      }
    }

    return filteredData
  }

  // 数据保留期限
  getDataRetentionPolicy(dataType) {
    const policies = {
      personalInfo: 365 * 7, // 7年
      medicalInfo: 365 * 10, // 10年
      usageInfo: 365 * 2,   // 2年
      temporaryData: 30      // 30天
    }

    return policies[dataType] || 365
  }

  // 自动清理过期数据
  async cleanupExpiredData() {
    const now = Date.now()

    for (const [dataType, retentionDays] of Object.entries(this.getDataRetentionPolicy())) {
      const expiredTime = now - (retentionDays * 24 * 60 * 60 * 1000)

      await this.deleteExpiredData(dataType, expiredTime)
    }
  }
}
```

## 安全监控

### 安全事件监控
```javascript
// 安全事件监控
class SecurityMonitor {
  constructor() {
    this.eventTypes = {
      LOGIN_SUCCESS: 'login_success',
      LOGIN_FAILURE: 'login_failure',
      PERMISSION_DENIED: 'permission_denied',
      DATA_ACCESS: 'data_access',
      DATA_MODIFICATION: 'data_modification',
      SUSPICIOUS_ACTIVITY: 'suspicious_activity'
    }

    this.alertThresholds = {
      loginFailures: 5,
      permissionDenials: 10,
      dataAccess: 100
    }
  }

  // 记录安全事件
  recordSecurityEvent(userId, eventType, eventData) {
    const event = {
      userId,
      eventType,
      eventData,
      timestamp: new Date(),
      ipAddress: eventData.ipAddress,
      userAgent: eventData.userAgent
    }

    // 保存到数据库
    this.saveSecurityEvent(event)

    // 检查是否需要告警
    this.checkAlertConditions(event)
  }

  // 检查告警条件
  async checkAlertConditions(event) {
    const recentEvents = await this.getRecentEvents(
      event.eventType,
      15 * 60 * 1000 // 15分钟内
    )

    const threshold = this.alertThresholds[event.eventType]

    if (threshold && recentEvents.length >= threshold) {
      await this.sendSecurityAlert(event, recentEvents)
    }
  }

  // 发送安全告警
  async sendSecurityAlert(event, relatedEvents) {
    const alert = {
      type: 'SECURITY_ALERT',
      severity: this.getSeverity(event.eventType),
      event,
      relatedEvents,
      timestamp: new Date()
    }

    // 发送告警通知
    await this.notifySecurityTeam(alert)

    // 记录告警日志
    console.warn('Security Alert:', alert)
  }

  // 获取告警严重程度
  getSeverity(eventType) {
    const severityMap = {
      'login_failure': 'low',
      'permission_denied': 'medium',
      'data_access': 'medium',
      'data_modification': 'high',
      'suspicious_activity': 'critical'
    }

    return severityMap[eventType] || 'low'
  }
}
```

### 异常行为检测
```javascript
// 异常行为检测
class AnomalyDetection {
  constructor() {
    this.baselineMetrics = {
      averageLoginTime: 0,
      averageDataAccess: 0,
      averageApiCalls: 0
    }

    this.anomalyThresholds = {
      loginTimeDeviation: 3, // 标准差倍数
      dataAccessSpike: 5,    // 倍数
      apiCallSpike: 10       // 倍数
    }
  }

  // 检测登录异常
  detectLoginAnomaly(userId, loginData) {
    const userHistory = await this.getUserLoginHistory(userId)

    if (userHistory.length === 0) {
      return null // 首次登录，无法比较
    }

    const averageLoginTime = this.calculateAverageLoginTime(userHistory)
    const deviation = Math.abs(loginData.loginTime - averageLoginTime)

    if (deviation > this.anomalyThresholds.loginTimeDeviation * this.calculateStandardDeviation(userHistory)) {
      return {
        type: 'login_time_anomaly',
        userId,
        expectedTime: averageLoginTime,
        actualTime: loginData.loginTime,
        deviation
      }
    }

    return null
  }

  // 检测数据访问异常
  detectDataAccessAnomaly(userId, accessData) {
    const userAccessHistory = await this.getUserAccessHistory(userId)

    if (userAccessHistory.length === 0) {
      return null
    }

    const averageAccess = this.calculateAverageAccess(userAccessHistory)

    if (accessData.accessCount > this.anomalyThresholds.dataAccessSpike * averageAccess) {
      return {
        type: 'data_access_anomaly',
        userId,
        averageAccess,
        actualAccess: accessData.accessCount,
        ratio: accessData.accessCount / averageAccess
      }
    }

    return null
  }

  // 检测地理位置异常
  detectLocationAnomaly(userId, locationData) {
    const userLocations = await this.getUserLocationHistory(userId)

    if (userLocations.length === 0) {
      return null
    }

    const lastLocation = userLocations[userLocations.length - 1]
    const distance = this.calculateDistance(lastLocation, locationData)

    // 如果两次登录位置距离超过1000公里，认为异常
    if (distance > 1000) {
      return {
        type: 'location_anomaly',
        userId,
        lastLocation,
        currentLocation: locationData,
        distance
      }
    }

    return null
  }

  // 计算两点间距离（公里）
  calculateDistance(loc1, loc2) {
    const R = 6371 // 地球半径（公里）
    const dLat = this.toRadians(loc2.latitude - loc1.latitude)
    const dLon = this.toRadians(loc2.longitude - loc1.longitude)

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(this.toRadians(loc1.latitude)) * Math.cos(this.toRadians(loc2.latitude)) *
              Math.sin(dLon/2) * Math.sin(dLon/2)

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
    return R * c
  }

  toRadians(degrees) {
    return degrees * (Math.PI / 180)
  }
}
```

## 合规性管理

### 法律法规合规
```javascript
// 合规性管理
class ComplianceManager {
  constructor() {
    this.applicableLaws = [
      '中华人民共和国网络安全法',
      '中华人民共和国个人信息保护法',
      '中华人民共和国未成年人保护法',
      '慈善法'
    ]

    this.complianceRequirements = {
      dataProtection: {
        consent: true,
        minimization: true,
        purposeLimitation: true,
        accuracy: true,
        storageLimitation: true
      },
      userRights: {
        access: true,
        correction: true,
        deletion: true,
        portability: true,
        objection: true
      },
      securityMeasures: {
        encryption: true,
        accessControl: true,
        auditLogging: true,
        incidentResponse: true
      }
    }
  }

  // 合规性检查
  async checkCompliance() {
    const results = {
      overall: true,
      details: {}
    }

    // 检查数据保护合规性
    results.details.dataProtection = await this.checkDataProtectionCompliance()

    // 检查用户权利合规性
    results.details.userRights = await this.checkUserRightsCompliance()

    // 检查安全措施合规性
    results.details.securityMeasures = await this.checkSecurityMeasuresCompliance()

    // 计算总体合规性
    results.overall = Object.values(results.details).every(detail => detail.compliant)

    return results
  }

  // 检查数据保护合规性
  async checkDataProtectionCompliance() {
    const checks = {
      consent: await this.checkConsentMechanism(),
      minimization: await this.checkDataMinimization(),
      purposeLimitation: await this.checkPurposeLimitation(),
      accuracy: await this.checkDataAccuracy(),
      storageLimitation: await this.checkStorageLimitation()
    }

    return {
      compliant: Object.values(checks).every(check => check),
      checks
    }
  }

  // 生成合规性报告
  async generateComplianceReport() {
    const complianceCheck = await this.checkCompliance()

    const report = {
      generatedAt: new Date(),
      applicableLaws: this.applicableLaws,
      complianceStatus: complianceCheck,
      recommendations: this.generateRecommendations(complianceCheck),
      nextReviewDate: this.calculateNextReviewDate()
    }

    return report
  }

  // 生成改进建议
  generateRecommendations(complianceCheck) {
    const recommendations = []

    for (const [category, details] of Object.entries(complianceCheck.details)) {
      if (!details.compliant) {
        for (const [requirement, status] of Object.entries(details.checks)) {
          if (!status) {
            recommendations.push({
              category,
              requirement,
              priority: this.getPriority(category, requirement),
              action: this.getRecommendedAction(category, requirement)
            })
          }
        }
      }
    }

    return recommendations.sort((a, b) => b.priority - a.priority)
  }
}
```

### 审计日志
```javascript
// 审计日志服务
class AuditLogger {
  constructor() {
    this.logLevels = {
      INFO: 'info',
      WARNING: 'warning',
      ERROR: 'error',
      CRITICAL: 'critical'
    }

    this.retentionPeriod = {
      info: 90 * 24 * 60 * 60 * 1000,    // 90天
      warning: 365 * 24 * 60 * 60 * 1000, // 1年
      error: 3 * 365 * 24 * 60 * 60 * 1000, // 3年
      critical: 7 * 365 * 24 * 60 * 60 * 1000 // 7年
    }
  }

  // 记录审计日志
  log(level, event, userId, details = {}) {
    const logEntry = {
      id: this.generateLogId(),
      timestamp: new Date(),
      level,
      event,
      userId,
      details,
      ipAddress: details.ipAddress,
      userAgent: details.userAgent,
      sessionId: details.sessionId
    }

    // 保存到数据库
    this.saveAuditLog(logEntry)

    // 如果是关键事件，发送告警
    if (level === this.logLevels.CRITICAL) {
      this.sendAlert(logEntry)
    }
  }

  // 查询审计日志
  async query(filters = {}) {
    const {
      userId,
      event,
      level,
      startTime,
      endTime,
      limit = 100,
      offset = 0
    } = filters

    const query = {}

    if (userId) query.userId = userId
    if (event) query.event = event
    if (level) query.level = level
    if (startTime || endTime) {
      query.timestamp = {}
      if (startTime) query.timestamp.$gte = startTime
      if (endTime) query.timestamp.$lte = endTime
    }

    const logs = await this.getAuditLogs(query, limit, offset)
    return logs
  }

  // 清理过期日志
  async cleanupExpiredLogs() {
    const now = Date.now()

    for (const [level, retentionPeriod] of Object.entries(this.retentionPeriod)) {
      const expiredTime = now - retentionPeriod

      await this.deleteExpiredLogs(level, expiredTime)
    }
  }

  // 生成日志ID
  generateLogId() {
    return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
}
```

## 应急响应

### 安全事件响应
```javascript
// 安全事件响应
class SecurityIncidentResponse {
  constructor() {
    this.incidentLevels = {
      LOW: 'low',
      MEDIUM: 'medium',
      HIGH: 'high',
      CRITICAL: 'critical'
    }

    this.responseProcedures = {
      dataBreach: this.handleDataBreach.bind(this),
      unauthorizedAccess: this.handleUnauthorizedAccess.bind(this),
      systemCompromise: this.handleSystemCompromise.bind(this),
      denialOfService: this.handleDenialOfService.bind(this)
    }
  }

  // 处理安全事件
  async handleSecurityIncident(incident) {
    // 记录事件
    await this.logIncident(incident)

    // 评估事件级别
    const level = this.assessIncidentLevel(incident)

    // 启动响应程序
    const procedure = this.responseProcedures[incident.type]

    if (procedure) {
      await procedure(incident, level)
    } else {
      await this.handleGenericIncident(incident, level)
    }

    // 通知相关人员
    await this.notifyStakeholders(incident, level)

    // 创建事件跟踪
    await this.createIncidentTracker(incident)
  }

  // 处理数据泄露事件
  async handleDataBreach(incident, level) {
    // 立即措施
    await this.containBreach(incident)

    // 评估影响范围
    const impact = await this.assessBreachImpact(incident)

    // 通知受影响用户
    if (level === this.incidentLevels.HIGH || level === this.incidentLevels.CRITICAL) {
      await this.notifyAffectedUsers(incident, impact)
    }

    // 向监管机构报告
    if (level === this.incidentLevels.CRITICAL) {
      await this.reportToRegulators(incident, impact)
    }

    // 修复漏洞
    await this.remmediateVulnerability(incident)
  }

  // 处理未授权访问事件
  async handleUnauthorizedAccess(incident, level) {
    // 立即撤销访问权限
    await this.revokeUnauthorizedAccess(incident)

    // 重置相关账户密码
    await this.resetAffectedAccounts(incident)

    // 审查访问日志
    await this.reviewAccessLogs(incident)

    // 加强安全措施
    await this.enhanceSecurityMeasures(incident)
  }

  // 评估事件级别
  assessIncidentLevel(incident) {
    const factors = {
      dataSensitivity: this.assessDataSensitivity(incident),
      userImpact: this.assessUserImpact(incident),
      systemImpact: this.assessSystemImpact(incident),
      businessImpact: this.assessBusinessImpact(incident)
    }

    const score = Object.values(factors).reduce((sum, factor) => sum + factor, 0)

    if (score >= 8) return this.incidentLevels.CRITICAL
    if (score >= 6) return this.incidentLevels.HIGH
    if (score >= 4) return this.incidentLevels.MEDIUM
    return this.incidentLevels.LOW
  }

  // 创建事件跟踪器
  async createIncidentTracker(incident) {
    const tracker = {
      incidentId: incident.id,
      status: 'open',
      level: this.assessIncidentLevel(incident),
      timeline: [
        {
          timestamp: new Date(),
          action: 'incident_detected',
          details: incident
        }
      ],
      assignedTo: this.assignIncidentOwner(incident),
      expectedResolution: this.calculateExpectedResolution(incident)
    }

    await this.saveIncidentTracker(tracker)
    return tracker
  }
}
```

## 安全培训

### 安全意识培训
```javascript
// 安全培训管理
class SecurityTraining {
  constructor() {
    this.trainingModules = {
      dataProtection: {
        title: '数据保护培训',
        duration: 30,
        content: [
          '个人信息保护的重要性',
          '数据分类和处理原则',
          '数据泄露预防和应对'
        ],
        quiz: [
          {
            question: '以下哪种信息属于敏感个人信息？',
            options: ['姓名', '身份证号', '性别', '年龄'],
            correct: 1
          }
        ]
      },

      passwordSecurity: {
        title: '密码安全培训',
        duration: 20,
        content: [
          '强密码的创建原则',
          '密码管理最佳实践',
          '多因素认证的使用'
        ],
        quiz: [
          {
            question: '强密码应该包含哪些元素？',
            options: [
              '只有字母',
              '只有数字',
              '字母、数字、特殊字符',
              '只有特殊字符'
            ],
            correct: 2
          }
        ]
      },

      phishingAwareness: {
        title: '钓鱼攻击防范',
        duration: 25,
        content: [
          '钓鱼攻击的常见特征',
          '如何识别钓鱼邮件',
          '防范钓鱼攻击的措施'
        ],
        quiz: [
          {
            question: '收到可疑邮件时应该怎么做？',
            options: [
              '直接点击链接',
              '回复邮件询问',
              '删除邮件并报告',
              '转发给朋友'
            ],
            correct: 2
          }
        ]
      }
    }
  }

  // 获取培训模块
  getTrainingModule(moduleName) {
    return this.trainingModules[moduleName]
  }

  // 完成培训
  async completeTraining(userId, moduleName, quizAnswers) {
    const module = this.getTrainingModule(moduleName)

    if (!module) {
      throw new Error('培训模块不存在')
    }

    // 评估测验结果
    const quizResult = this.evaluateQuiz(module.quiz, quizAnswers)

    if (quizResult.score < 0.8) {
      throw new Error('测验成绩不达标，请重新学习')
    }

    // 记录培训完成
    const record = {
      userId,
      moduleName,
      completedAt: new Date(),
      score: quizResult.score,
      certificateId: this.generateCertificateId()
    }

    await this.saveTrainingRecord(record)

    return {
      success: true,
      score: quizResult.score,
      certificateId: record.certificateId
    }
  }

  // 评估测验
  evaluateQuiz(quiz, answers) {
    let correctCount = 0

    for (let i = 0; i < quiz.length; i++) {
      if (answers[i] === quiz[i].correct) {
        correctCount++
      }
    }

    return {
      totalQuestions: quiz.length,
      correctAnswers: correctCount,
      score: correctCount / quiz.length
    }
  }

  // 生成证书ID
  generateCertificateId() {
    return `CERT_${Date.now()}_${Math.random().toString(36).substr(2, 9).toUpperCase()}`
  }
}
```

## 安全配置

### 安全配置管理
```javascript
// 安全配置管理
class SecurityConfig {
  constructor() {
    this.defaultConfig = {
      passwordPolicy: {
        minLength: 8,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: true,
        maxAge: 90 * 24 * 60 * 60 * 1000, // 90天
        historyCount: 5 // 不能重复使用最近5个密码
      },

      sessionPolicy: {
        timeout: 30 * 60 * 1000, // 30分钟
        maxConcurrentSessions: 3,
        requireReauth: true,
        reauthInterval: 8 * 60 * 60 * 1000 // 8小时
      },

      accessPolicy: {
        maxLoginAttempts: 5,
        lockoutDuration: 30 * 60 * 1000, // 30分钟
        requireMfa: true,
        allowedIpRanges: [] // 空表示不限制
      },

      dataPolicy: {
        encryptionAtRest: true,
        encryptionInTransit: true,
        backupRetention: 30 * 24 * 60 * 60 * 1000, // 30天
        auditRetention: 365 * 24 * 60 * 60 * 1000 // 1年
      }
    }
  }

  // 获取安全配置
  getConfig(category) {
    return this.defaultConfig[category] || {}
  }

  // 更新安全配置
  async updateConfig(category, updates) {
    const currentConfig = this.getConfig(category)
    const newConfig = { ...currentConfig, ...updates }

    // 验证配置
    this.validateConfig(category, newConfig)

    // 保存配置
    await this.saveSecurityConfig(category, newConfig)

    // 记录配置变更
    await this.logConfigChange(category, currentConfig, newConfig)

    return newConfig
  }

  // 验证配置
  validateConfig(category, config) {
    const validators = {
      passwordPolicy: this.validatePasswordPolicy,
      sessionPolicy: this.validateSessionPolicy,
      accessPolicy: this.validateAccessPolicy,
      dataPolicy: this.validateDataPolicy
    }

    const validator = validators[category]

    if (validator) {
      return validator.call(this, config)
    }

    return true
  }

  // 验证密码策略
  validatePasswordPolicy(config) {
    if (config.minLength < 8) {
      throw new Error('密码最小长度不能少于8位')
    }

    if (config.maxAge < 7 * 24 * 60 * 60 * 1000) {
      throw new Error('密码有效期不能少于7天')
    }

    return true
  }

  // 验证会话策略
  validateSessionPolicy(config) {
    if (config.timeout < 5 * 60 * 1000) {
      throw new Error('会话超时时间不能少于5分钟')
    }

    if (config.maxConcurrentSessions < 1) {
      throw new Error('最大并发会话数不能少于1个')
    }

    return true
  }
}
```

这个安全隐私保护方案涵盖了身份认证、数据保护、网络安全、隐私保护、安全监控、合规管理、应急响应等各个方面，确保系统能够保护儿童和家庭的敏感信息，符合相关法律法规的要求。